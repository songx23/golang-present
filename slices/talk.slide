# Slice, the little-known side
21 February 2023

Song Xue
Lead Software Engineer, Digio
song.xue@digio.com.au
https://github.com/songx23/golang-present

## What we will cover?

- Slice vs Array
- Slice Length vs Capacity
- Copying a Slice
- Nil vs Empty Slices
- Slice Append Side-Effects
- Slice Memory Leak

## Slice

Probably the *MOST* used data structure in Go.


// Very hard to not write something to do with slice in day-to-day coding.

**Slice vs Array**

The definition of arrays vs slices confused me when I started learning Go.

// Go Tour didn't mention array at all. Made me think that slice is the Go way of calling an array.

- What is an array?

- What is a slice?

// A slice holds a pointer to the backing array plus other contextual information which we will cover very soon.

- How are they different?

// The basic difference between a slice and an array is that a slice is a reference to a contiguous segment of an array.
// Unlike an array, which is a value-type, slice is a reference type. A slice can be a complete array or a part of an array,
// indicated by the start and end index. A slice, therefore, is also an array that pours a context of dynamism onto the
// underlying array, which otherwise is a static contiguous memory allocation.

## Length & Capacity

Slice has more context on top of the underlying array. The 2 most important pieces of information are **Length** and
**Capacity**

- What is the length of a slice?

// Length is the number of elements the slice contains

- What is the capacity of a slice?

// Capacity is the number of elements in the backing array

.play examples/length_capacity.go

## Slice initialisation (nil vs empty)

a slice is empty if its length is equal to 0
a slice is nil if it equals to nil

// main difference:
// initializing a nil slice doesn't require any allocation
// regardless of whether a slice is nil, calling the `append` function works, `range` operator also works

// returning a nil slice is preferred as it doesn't require any allocations
// when handling json, nil slice -> empty field (omit), empty slice -> []

## How can we make use of capacity and length?

// Map from a slice of type A to a slice of type B
// Explain the backing array copying
// Present the performance difference between initialise with length & capacity vs without.
// Benchmark solution: 3 options
// Empty Slice
// Given Capacity (all-rounder)
// Given Length (fastest but not always possible)

    original := []string{"a", "b", "c"}

## A gotcha based on how slice is copied

// s1 []int 3, 6
// s2 s1[1:3] => []int 2, 5
// s1 and s2 backing array is the same, hence change 1, change both
// s2 append til full
// s2 backing array is different now, hence s2 doesn't affect s1 anymore

