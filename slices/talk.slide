# Slice, the little-known side
21 February 2023

Song Xue
Lead Software Engineer, Digio
song.xue@digio.com.au
https://github.com/songx23/golang-present

## Slice

Probably the *MOST* used data structure in Go.
// Very hard to not write something to do with slice in day-to-day coding.


But even the most familiar data structure has some dark secrets, which could cause unexpected problems.
// Let's uncover them today.

Firstly, let's go over some basic concepts.

## Slice vs Array

The definition of arrays vs slices confused me when I started learning Go.

The Go Tour didn't mention "array" at all which made me think that slice is the Go way of calling an array.

In day-to-day work, I feel like people are using these 2 concepts interchangeably.

## What is an array?

An array is a homogeneous data structure of a fixed length. Two important characteristics here:
1. Homogeneous: can only hold elements of the same type
2. Fixed length: can't be
Presentation:
`var arr [10]int`

## What is a slice?

A slice is a reference to a contiguous segment of an array (backing array).
Since it's a reference, slice is a reference type (pointer).
// A slice holds a pointer to the backing array plus other contextual information which we will cover very soon.

.image ./images/slice-definition.png

## How are they different?

1. Array is a value type (like primitive types). Slice is a reference type (pointer).

.play ./examples/value-vs-reference/main.go

## How are they different?

2. Array is a fixed length data structure. Slice refers to a backing array hence its length is not fixed.

```go
	// ARRAY
	s := [3]int{1, 2, 3}
	s = append(s, 1) // compile error
	fmt.Println(s)
	// SLICE
	s1 := []int{1, 2, 3}
	s1 = append(s1, 4)
	fmt.Println(s1) // [1, 2, 3, 4]
```

## Length & Capacity

Slice has more context on top of the underlying array. The 2 most important pieces of information are **Length** and
**Capacity**

- What is the length of a slice?

// Length is the number of elements the slice contains

- What is the capacity of a slice?

// Capacity is the number of elements in the backing array

.play examples/length-capacity/main.go

## Slice initialisation

.play examples/slice-init/main.go

// a slice is empty if its length is equal to 0
// a slice is nil if it equals to nil

## Slice initialisation (nil vs empty)

**Key takeaways:**
- Initializing a nil slice doesn't require any allocation.
That's why we normally don't see the third and fourth slice initialisation.
- Regardless of whether a slice is nil, calling the `append` function works, `range` operator also works.
- Returning a nil slice is preferred as it doesn't require any allocations.
- When we need to marshal a slice to json.

nil slice -> `{}`

empty slice -> `{"slice": []}`

## How can we make use of capacity and length?

Imagine if we have a mapper function like below:



```go
func mapWithNilSlice(a []string) []string {
	var b []string
	for _, v := range a {
		b = append(b, strings.ToUpper(v))
	}
	return b
}
```

## What happens under the hood?

.image ./images/slice-backing-array-copy-1.png

.image ./images/slice-backing-array-copy-2.png

## What happens under the hood?

.image ./images/slice-backing-array-copy-3.png

.image ./images/slice-backing-array-copy-4.png

// Explain the backing array copying

## Give a helping hand

There's no reason why we don't give Go a helping hand. If we declare the capacity beforehand, we could avoid copying the backing array.

```go
func mapWithPredefinedCapacity(a []string) []string {
	b := make([]string, 0, len(a))
	for _, v := range a {
		b = append(b, strings.ToUpper(v))
	}
	return b
}
```

Even further, we can pre-populate the elements with default value like below. This saves us from appending elements to the mapped slice.

```go
func mapWithPredefinedLength(a []string) []string {
	b := make([]string, len(a))
	for i := range a {
		b[i] = strings.ToUpper(a[i])
	}
	return b
}
```

## Benchmark

Benchmark test code can be found in `./examples/slice-backing-array-copy/main_test.go`.

Here are the results:

```
Benchmark_mapWithNilSlice
Benchmark_mapWithNilSlice-10              	     438	   2599940 ns/op
Benchmark_mapWithPredefinedCapacity
Benchmark_mapWithPredefinedCapacity-10    	     720	   1663941 ns/op
Benchmark_mapWithPredefinedLength
Benchmark_mapWithPredefinedLength-10      	     746	   1600166 ns/op
```
// Benchmark solution: 3 options
// Empty Slice
// Given Capacity (all-rounder)
// Given Length (fastest but not always possible)


## 2 built-in functions: copy and append

## Another gotcha of the built-in copy function

//  src := []int{0,1,2}
//  var dst []int
//  copy(dst, src)
//  fmt.Println(dst)
//  this prints []
//  To use copy effectively, it’s essential to understand that the number of elements copied to the destination slice
// corresponds to the minimum between:
// The source slice’s length
// The destination slice’s length

## A gotcha based on how slice is copied

// s1 []int 1, 2, 3   l=3, c=3  later become 1, 2, 10
// s2 s1[1:2] => []int 2   l=1, c=2
// s3 append(s2, 10) => []int 2, 10 l=2, c=2
// s1, s2, s3 backing array is the same, hence change 1, change both s1 and s3
// s3 append til full
// s3 backing array is different now, hence s3 doesn't affect s1 anymore

// be careful when passing a slice into a function. The function could change the slice elements. For defensive reasons,
// we can make a copy of the slice and then modify it. Function programming. Immutable. Or use full slice expression
// [low:high:max] capacity = max-low

// When using slicing, we must remember that we can face a situation leading to unintended side effects.
// If the resulting slice has a length smaller than its capacity, append can mutate the original slice.
// If we want to restrict the range of possible side effects, we can use either a slice copy or the full slice expression,
// which prevents us from doing a copy.

## Memory leaks

## Leaking capacity

// Remember that when creating a slice, the capacity will follow the original slice.
// for example creating a [:5] slice based on a one-million-item array, the capacity will be 1mil-5
// As a rule of thumb, remember that slicing a large slice or array can lead to potential high memory consumption.
// The remaining space won’t be reclaimed by the GC, and we can keep a large backing array despite using only a few elements.
// Using a slice copy is the solution to prevent such a case.

// Using full slice expression doesn't help in this case even calling `runtime.GC()` specifically


## Leaking pointer

    func main() {
        foos := make([]Foo, 1_000)
        printAlloc()

        for i := 0; i < len(foos); i++ {
            foos[i] = Foo {
                v : make([]byte, 1024*1024),
            }
        }
        printAlloc()

        two := keepFirstTwoElementsOnly(foos)
        runtime.GC()
        printAlloc()
        runtime.KeepAlive(two)
    }

    func keepFirstTwoElementsOnly(foos []Foo) []Foo {
        return foos[:2]
    }

    func printAlloc() {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        fmt.Printf("%d KB\n", m.Alloc/1024)
    }

// It’s essential to keep this rule in mind when working with slices:
// if the element is a pointer or a struct with pointer fields, the elements won’t be reclaimed by the GC.
// In our example, because Foo contains a slice (and a slice is a pointer on top of a backing array),
// the remaining 998 Foo elements and their slice aren’t reclaimed. Therefore, even though these 998 elements can’t be accessed,
// they stay in memory as long as the variable returned by keepFirstTwoElementsOnly is referenced.

// The solution is again use `copy` function and make a 2 length slice

// In each topic, give a key takeaways


## Recap: what we covered?

Definitions
- Slice vs Array
- Slice Length vs Capacity
- Slice initialisations

Potential problems with slices
- performance: map from a slice to another slice
- side-effects: built-in copy function
- side-effects: built-in append function
- performance: Slice Memory Leak